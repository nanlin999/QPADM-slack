//The parallel QPADM
#include <RcppArmadillo.h>
// [[Rcpp::depends(RcppArmadillo)]]
#include <chrono>
using namespace Rcpp;
using namespace arma;

//The soft-thresholding solution of r
// [[Rcpp::export]]
arma::vec shrinkcpp(arma::vec u, arma::vec v){
  arma::vec w=(1+sign(u-v))/2%(u-v)-(1+sign(-u-v))/2%(-u-v);
  return w;
}


//The derivative of the penalty term
//[[Rcpp::export]]
arma::vec deriv(arma::vec beta, double a, double lambda, std::string penalty){
  int p = beta.n_elem;
  arma::vec df = arma::zeros(p);
  if(penalty=="scad"){
    for(int j=0;j<p;j++){
      if(fabs(beta(j))<=lambda) df(j)=lambda;
      else if(fabs(beta(j))<=a*lambda) df(j)=(a*lambda-fabs(beta(j)))/(a-1);
    }
  }else{
    for(int j=0;j<p;j++){
      if(fabs(beta(j))<=a*lambda) df(j)=lambda-fabs(beta(j))/a;
    }
  }
  return df;
}



//The MCP penalty (sum)
//[[Rcpp::export]]
double gmcp2(arma::vec z, double lambda, double a){
  
  int num = z.size();
  arma::vec pz(num, fill::zeros);
  for(int j = 0; j < num; j++){
    if(abs(z(j)) > a*lambda)
      pz(j) = 0.5*a*lambda*lambda;
    else
      pz(j) = lambda*abs(z(j))-0.5*z(j)*z(j)/a;
  }
  return sum(pz);
}


//The SCAD penalty (sum)
//[[Rcpp::export]]
double gscad2(arma::vec z,double lambda,double a){
  
  int num = z.size();
  arma::vec pz(num, fill::zeros);
  for(int j = 0; j < num; j++){
    if(abs(z(j)) >= a*lambda)
      pz(j) = 0.5*(a+1)*lambda*lambda;
    else if(abs(z(j)) <= lambda)
      pz(j) = lambda*abs(z(j));
    else
      pz(j) = (a*lambda*abs(z(j))-0.5*(z(j)*z(j)+lambda*lambda))/(a-1);
  }
  return sum(pz);
}


//The checkloss fuction
//[[Rcpp::export]]
double checkloss(arma::vec u, double tau){
  int num = u.size();
  arma::vec loss(num, fill::zeros);
  for(int j = 0; j < num; j++){
    if(u(j) > 0) loss(j) = tau*u(j);
    else loss(j) = (tau-1)*u(j);
  }
  return accu(loss); 
}



//The parallel QPADM
// [[Rcpp::export]]
arma::mat qpadmdisCPP(double eps,arma::mat xr,arma::vec yr,int iter,int M,double ta,double rhor,double lambdar,double a,std::string penalty,arma::vec bt){
  
  int maxit=(iter);
  double tau=(ta),rho=(rhor),lambda=(lambdar);
  arma::mat x=(xr);
  arma::vec y=(yr);
  int n=x.n_rows, p=x.n_cols;
  int ni = n/M;
  lambda = lambda/n;
  eps = eps*M;
  
  arma::vec betaini=arma::zeros(p), rini=arma::zeros(n), uini=arma::zeros(n), beta_avgini=arma::zeros(p), eta_avgini=arma::zeros(p); 
  arma::vec beta=arma::zeros(p), r=arma::zeros(n), u=arma::zeros(n); 
  arma::mat betaiini=arma::zeros(p,M),etaiini=arma::zeros(p,M);
  arma::mat betai=arma::zeros(p,M),etai=arma::zeros(p,M);
  arma::vec yx = y;
  arma::vec df;
  
  double time = 0,max_prep=0,max_map=0,time_reduce=0;
  arma::vec map(M,fill::zeros);
  
  arma::vec final(3, fill::zeros);
  arma::vec traceloss(maxit, fill::zeros);
  
  arma::cube dat=arma::zeros<arma::cube>(p,p,M);
  for(int i=0;i<M;i++){
    arma::mat tmp,xi=x.rows(ni*i,ni*i+ni-1);
    auto start_prep = std::chrono::high_resolution_clock::now();
    if(ni>p) 
      tmp = inv(xi.t()*xi+arma::eye(p,p));
    else tmp = arma::eye(p,p)-xi.t()*inv(xi*xi.t()+arma::eye(ni,ni))*xi;
    auto finish_prep = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double> elapsed_prep = finish_prep - start_prep;
    if(elapsed_prep.count()>max_prep) max_prep = elapsed_prep.count();
    dat.slice(i)=tmp;
  }
  time = time+max_prep;
  
  int iteration=0;
  double distance = 1;
  
  double lossold = 0, loss = 0;
  
  if(penalty == "mcp"){
    lossold = checkloss(rini,tau)+gmcp2(betaini, lambda, a);
  }
  else{
    lossold = checkloss(rini,tau)+gscad2(betaini, lambda, a);
  }
  
  if(tau==0.5){
    eps=eps/M*100;
  }
  
  while((distance>eps)&&(iteration<maxit)){
  //while(iteration<maxit){
    
    beta_avgini=mean(betaiini,1);
    eta_avgini=mean(etaiini,1);
    
    auto start_reduce = std::chrono::high_resolution_clock::now();
    
    //update beta
    df = deriv(betaini,a,lambda,penalty);
    beta=shrinkcpp(beta_avgini+eta_avgini/rho,df/(rho*M));
    
    auto finish_reduce = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double> elapsed_reduce = finish_reduce - start_reduce;
    time_reduce = elapsed_reduce.count();
    time = time+time_reduce;
    
    for(int i=0;i<M;i++){
      
      arma::vec yi=y.subvec(ni*i,ni*i+ni-1),uiini=uini.subvec(ni*i,ni*i+ni-1);
      arma::mat xi=x.rows(ni*i,ni*i+ni-1);
      auto start_map=std::chrono::high_resolution_clock::now();
      //update r
      r.subvec(ni*i,ni*i+ni-1)=shrinkcpp(uiini/rho+yx.subvec(ni*i,ni*i+ni-1)-.5*(2*tau-1)/(n*rho),.5*arma::ones<arma::vec>(ni)/(n*rho));
      //update betai
      betai.col(i)=dat.slice(i)*(xi.t()*(yi-r.subvec(ni*i,ni*i+ni-1)+uiini/rho)-etaiini.col(i)/rho+beta);
      //update u and eta
      yx.subvec(ni*i,ni*i+ni-1)=yi-xi*betai.col(i);
      u.subvec(ni*i,ni*i+ni-1)=uini.subvec(ni*i,ni*i+ni-1)+rho*(yx.subvec(ni*i,ni*i+ni-1)-r.subvec(ni*i,ni*i+ni-1));
      etai.col(i)=etaiini.col(i)+rho*(betai.col(i)-beta);
      auto finish_map = std::chrono::high_resolution_clock::now();
      std::chrono::duration<double> elapsed_map = finish_map - start_map;
      map(i)=elapsed_map.count();
    }
    
    max_map = map(map.index_max());
    time = time+max_map;
    
    if(penalty == "mcp"){
      loss = checkloss(r,tau)+gmcp2(beta, lambda, a);
    }
    else{
      loss = checkloss(r,tau)+gscad2(beta, lambda, a);
    }
    
    distance = abs(lossold-loss);
    traceloss(iteration) = lossold;
    
    lossold = loss;
    betaini = beta, rini = r, uini = u;
    betaiini = betai, etaiini = etai;
    iteration = iteration + 1;
  }
  
  final(0) = sum(abs(beta-bt));
  final(1) = time;
  final(2) = iteration;
  return final;
  //return traceloss;
  
}
