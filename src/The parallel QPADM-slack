//The parallel QPADM-slack 
#include <RcppArmadillo.h>
#include <math.h>
#include <chrono>
//[[Rcpp::depends(RcppArmadillo)]]
using namespace Rcpp;
using namespace arma;
using namespace std;

//Covariance matrix
//[[Rcpp::export]]
arma::mat gcov(int p, double rho){
  arma::mat cov(p, p, fill::eye);
  for(int i = 0; i < p; i++){
    for(int j = 0; j < p; j++){
      if(i < j) cov(i,j) = pow(rho, j-i);
      else cov(i,j) = cov(j,i);
    }
  }
  return cov;
}

//The SCAD penalty
double gscad(double z,double lambda,double a){  
  double pz;
  if(abs(z) >= a*lambda)
    pz = 0.5*(a+1)*lambda*lambda;
  else if(abs(z) <= lambda)
    pz = lambda*abs(z);
  else
    pz = (a*lambda*abs(z)-0.5*(z*z+lambda*lambda))/(a-1);
  return pz;
}

//The MCP penalty
double gmcp(double z, double lambda, double a){ 
  double pz;
  if(abs(z) > a*lambda)
    pz = 0.5*a*lambda*lambda;
  else
    pz = lambda*abs(z)-0.5*z*z/a;
  return pz;  
}

//The parallel QPADM-slack
//[[Rcpp::export]]
arma::mat QPADMslackparaCPP(arma::vec y, arma::mat x, arma::vec betatrue, double tau, double lambda, double a, double pho, int K, String funname, int maxstep, double eps, bool intercept){  
  int n = x.n_rows, nk = n/K;
  if(intercept){
    x.insert_cols(0, arma::ones(n));
  }
  int p = x.n_cols;
  arma::mat zini(p, K, fill::zeros), uini(p, K, fill::zeros), z(p, K, fill::zeros), u(p, K, fill::zeros);
  arma::vec xiini(n, fill::zeros), etaini(n, fill::zeros), vini(n, fill::zeros), betaini(p, fill::zeros);
  arma::vec xi(n, fill::zeros), eta(n, fill::zeros), v(n, fill::zeros), beta(p, fill::zeros);
  arma::vec zinimean = mean(zini,1), uinimean = mean(uini,1), yx = y, value(3, fill::zeros), map(K, fill::zeros);
  double max_prep =0, time_reduce = 0, max_map = 0, time = 0, distance = 1;
  int iteration = 0;
  arma::cube tmp=arma::zeros<arma::cube>(p,p,K);
  for(int k=0;k<K;k++){
    arma::mat tmp2, xk=x.rows(k*nk,k*nk+nk-1);
    auto start_prep = std::chrono::high_resolution_clock::now();
    if(nk>p) 
      tmp2 = inv(arma::eye(p,p)+xk.t()*xk);
    else tmp2 = arma::eye(p,p)-xk.t()*inv(arma::eye(nk,nk)+xk*xk.t())*xk;
    auto finish_prep = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double> elapsed_prep = finish_prep - start_prep;
    if(elapsed_prep.count()>max_prep) max_prep = elapsed_prep.count();
    tmp.slice(k)=tmp2;
  }
  time = time + max_prep;
  while(((distance > eps)|(distance == 0))&&(iteration < maxstep)){
    zinimean = mean(zini,1);
    uinimean = mean(uini,1);
    auto start_reduce = std::chrono::high_resolution_clock::now();
    if(funname == "mcp"){
      for(int j=0;j<p;j++){
        double phi = zinimean(j)+uinimean(j)/pho;
        arma::vec xx(3, fill::zeros);
        xx(0) = sign(phi)*min(a*lambda, max(0.0, a*(pho*K*abs(phi)-lambda)/(pho*K*a-1)));
        xx(1) = sign(phi)*max(a*lambda, abs(phi));
        arma::vec h(3, fill::zeros);
        for(int i = 0; i < 3; i++){
          h(i) = 0.5*(xx(i)-phi)*(xx(i)-phi)+gmcp(xx(i), lambda, a)/(pho*K); 
        }
        beta(j) = xx(h.index_min());
      }
    }
    else{
      for(int j = 0; j < p; j++){
        double phi = zinimean(j)+uinimean(j)/pho;
        arma::vec xx(4, fill::zeros);
        xx(0) = sign(phi)*min(lambda, max(0.0, abs(phi)-lambda/(pho*K)));
        xx(1) = sign(phi)*min(a*lambda, max(lambda, (pho*K*(a-1)*abs(phi)-a*lambda)/(pho*K*(a-1)-1)));
        xx(2) = sign(phi)*max(a*lambda, abs(phi));
        arma::vec h(4, fill::zeros);
        for(int i = 0; i < 4; i++){
          h(i) = 0.5*(xx(i)-phi)*(xx(i)-phi)+gscad(xx(i), lambda, a)/(pho*K); 
        }
        beta(j) = xx(h.index_min());
      }
    }
    auto finish_reduce = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double> elapsed_reduce = finish_reduce - start_reduce;
    time_reduce = elapsed_reduce.count();
    time = time + time_reduce;
    for(int k = 0; k < K; k++){
      arma::mat xk = x.rows(k*nk,k*nk+nk-1);
      auto start_map = std::chrono::high_resolution_clock::now();
      xi.subvec(k*nk,k*nk+nk-1) = yx.subvec(k*nk,k*nk+nk-1)+etaini.subvec(k*nk,k*nk+nk-1)+vini.subvec(k*nk,k*nk+nk-1)/pho-tau*arma::ones(nk)/pho;
      for(int i=k*nk;i<k*nk+nk;i++){
       if(xi(i)<0){
          xi(i) = 0;
        }
      }
      eta.subvec(k*nk,k*nk+nk-1) = -yx.subvec(k*nk,k*nk+nk-1)+xi.subvec(k*nk,k*nk+nk-1)-vini.subvec(k*nk,k*nk+nk-1)/pho-(1-tau)*arma::ones(nk)/pho;
      for(int i=k*nk;i<k*nk+nk;i++){
        if(eta(i)<0){
          eta(i) = 0;
        }
      }
      z.col(k) = tmp.slice(k)*(beta-uini.col(k)/pho+xk.t()*(y.subvec(k*nk,k*nk+nk-1)-xi.subvec(k*nk,k*nk+nk-1)+eta.subvec(k*nk,k*nk+nk-1)+vini.subvec(k*nk,k*nk+nk-1)/pho));     
      yx.subvec(k*nk,k*nk+nk-1) = y.subvec(k*nk,k*nk+nk-1)-xk*z.col(k);
      u.col(k) = uini.col(k)+pho*(z.col(k)-beta);
      v.subvec(k*nk,k*nk+nk-1) = vini.subvec(k*nk,k*nk+nk-1)+pho*(yx.subvec(k*nk,k*nk+nk-1)-xi.subvec(k*nk,k*nk+nk-1)+eta.subvec(k*nk,k*nk+nk-1));        
      auto finish_map = std::chrono::high_resolution_clock::now();
      std::chrono::duration<double> elapsed_map = finish_map - start_map;
      map(k) = elapsed_map.count();     
    }
    max_map = map(map.index_max());
    time = time + max_map;
    distance = sum(abs(beta-betaini));
    betaini = beta, zini = z, uini = u, xiini = xi, etaini = eta, vini=v;
    iteration = iteration+1;
  }    
  value(0) = sum(abs(beta-betatrue));
  value(1) = time;
  value(2) = iteration;
  return value;
}
