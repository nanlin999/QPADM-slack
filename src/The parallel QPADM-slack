// The parallel QPADM-slack 
#include <RcppArmadillo.h>
#include <math.h>
#include <chrono>
//[[Rcpp::depends(RcppArmadillo)]]
using namespace Rcpp;
using namespace arma;
using namespace std;

//Covariance matrix
//[[Rcpp::depends(RcppArmadillo)]]
arma::mat gcov(int p, double rho){
  arma::mat cov(p, p, fill::eye);
  for(int i = 0; i < p; i++){
    for(int j = 0; j < p; j++){
      if(i < j) cov(i,j) = pow(rho, j-i);
      else cov(i,j) = cov(j,i);
    }
  }
  return cov;
}

//The SCAD penalty
double gscad(double z,double lambda,double a){  
  double pz;
  if(abs(z) >= a*lambda)
    pz = 0.5*(a+1)*lambda*lambda;
  else if(abs(z) <= lambda)
    pz = lambda*abs(z);
  else
    pz = (a*lambda*abs(z)-0.5*(z*z+lambda*lambda))/(a-1);
  return pz;
}

//The SCAD penalty (sum)
double gscad2(arma::vec z,double lambda,double a){  
  int num = z.size();
  arma::vec pz(num, fill::zeros);
  for(int j = 0; j < num; j++){
    if(abs(z(j)) >= a*lambda)
      pz(j) = 0.5*(a+1)*lambda*lambda;
    else if(abs(z(j)) <= lambda)
      pz(j) = lambda*abs(z(j));
    else
      pz(j) = (a*lambda*abs(z(j))-0.5*(z(j)*z(j)+lambda*lambda))/(a-1);
  }
  return sum(pz);
}

//The MCP penalty
double gmcp(double z, double lambda, double a){ 
  double pz;
  if(abs(z) > a*lambda)
    pz = 0.5*a*lambda*lambda;
  else
    pz = lambda*abs(z)-0.5*z*z/a;
  return pz;  
}

//The MCP penalty (sum)
double gmcp2(arma::vec z, double lambda, double a){ 
  int num = z.size();
  arma::vec pz(num, fill::zeros);
  for(int j = 0; j < num; j++){
    if(abs(z(j)) > a*lambda)
      pz(j) = 0.5*a*lambda*lambda;
    else
      pz(j) = lambda*abs(z(j))-0.5*z(j)*z(j)/a;
  }
  return sum(pz);
}

//maxfunction
double maxf(double a, double b){
  if(a>=b)
    return a;
  else
    return b;
}

//minfunction
double minf(double a, double b){
  if(a<b)
    return a;
  else
    return b;
}

//The parallel QPADM-slack
arma::mat QPADMslackpara(double eps, arma::vec y, arma::mat x, arma::vec betatrue, double tau, double lambda, double a, double pho, int K, String funname, int maxstep){  
  int n = x.n_rows, p = x.n_cols, nk = n/K;
  eps = eps*K;
  arma::mat zini(p, K, fill::zeros), uini(p, K, fill::zeros);
  arma::vec xiini(n, fill::zeros), etaini(n, fill::zeros), vini(n, fill::zeros);
  arma::vec betaini(p, fill::zeros);
  arma::mat z(p, K, fill::zeros), u(p, K, fill::zeros);
  arma::vec xi(n, fill::zeros), eta(n, fill::zeros), v(n, fill::zeros);
  arma::vec beta(p, fill::zeros);
  arma::vec zinimean = mean(zini,1);
  arma::vec uinimean = mean(uini,1);
  arma::vec yx = y;
  arma::vec final(3, fill::zeros);
  arma::vec traceloss(maxstep, fill::zeros);
  double max_prep =0, time_reduce = 0, max_map = 0, time = 0;
  arma::vec map(K, fill::zeros);
  double distance = 1, lossold = 0, loss = 0; 
  if(funname == "mcp"){
    lossold = tau*accu(xiini)+(1-tau)*accu(etaini)+gmcp2(betaini, lambda, a);
  }
  else{
    lossold = tau*accu(xiini)+(1-tau)*accu(etaini)+gscad2(betaini, lambda, a);
  }
  arma::cube tmp=arma::zeros<arma::cube>(p,p,K);
  for(int k=0;k<K;k++){
    arma::mat tmp2, xk=x.rows(k*nk,k*nk+nk-1);
    auto start_prep = std::chrono::high_resolution_clock::now();
    if(nk>p) 
      tmp2 = inv(arma::eye(p,p)+xk.t()*xk);
    else tmp2 = arma::eye(p,p)-xk.t()*inv(arma::eye(nk,nk)+xk*xk.t())*xk;
    auto finish_prep = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double> elapsed_prep = finish_prep - start_prep;
    if(elapsed_prep.count()>max_prep) max_prep = elapsed_prep.count();
    tmp.slice(k)=tmp2;
  }
  time = time + max_prep;
  int iteration = 0;

  while((distance > eps)&&(iteration < maxstep)){
  //while((iteration < maxstep)){
    zinimean = mean(zini,1);
    uinimean = mean(uini,1);
    auto start_reduce = std::chrono::high_resolution_clock::now();
    if(funname == "mcp"){
      for(int j=0;j<p;j++){
        double phi = zinimean(j)+uinimean(j)/pho;
        arma::vec xx(3, fill::zeros);
        xx(0) = sign(phi)*minf(a*lambda, maxf(0, a*(pho*K*abs(phi)-lambda)/(pho*K*a-1)));
        xx(1) = sign(phi)*maxf(a*lambda, abs(phi));
        arma::vec h(3, fill::zeros);
        for(int i = 0; i < 3; i++){
          h(i) = 0.5*(xx(i)-phi)*(xx(i)-phi)+gmcp(xx(i), lambda, a)/(pho*K); 
        }
        beta(j) = xx(h.index_min());
      }
    }
    else{
      for(int j = 0; j < p; j++){
        double phi = zinimean(j)+uinimean(j)/pho;
        arma::vec xx(4, fill::zeros);
        xx(0) = sign(phi)*minf(lambda, maxf(0, abs(phi)-lambda/(pho*K)));
        xx(1) = sign(phi)*minf(a*lambda, maxf(lambda, (pho*K*(a-1)*abs(phi)-a*lambda)/(pho*K*(a-1)-1)));
        xx(2) = sign(phi)*maxf(a*lambda, abs(phi));
        arma::vec h(4, fill::zeros);
        for(int i = 0; i < 4; i++){
          h(i) = 0.5*(xx(i)-phi)*(xx(i)-phi)+gscad(xx(i), lambda, a)/(pho*K); 
        }
        beta(j) = xx(h.index_min());
      }
    }
    auto finish_reduce = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double> elapsed_reduce = finish_reduce - start_reduce;
    time_reduce = elapsed_reduce.count();
    time = time + time_reduce;
    for(int k = 0; k < K; k++){
      arma::mat xk = x.rows(k*nk,k*nk+nk-1);
      auto start_map = std::chrono::high_resolution_clock::now();
      xi.subvec(k*nk,k*nk+nk-1) = yx.subvec(k*nk,k*nk+nk-1)+etaini.subvec(k*nk,k*nk+nk-1)+vini.subvec(k*nk,k*nk+nk-1)/pho-tau*arma::ones(nk)/pho;
      for(int i=k*nk;i<k*nk+nk;i++){
       if(xi(i)<0){
          xi(i) = 0;
        }
      }
      eta.subvec(k*nk,k*nk+nk-1) = -yx.subvec(k*nk,k*nk+nk-1)+xi.subvec(k*nk,k*nk+nk-1)-vini.subvec(k*nk,k*nk+nk-1)/pho-(1-tau)*arma::ones(nk)/pho;
      for(int i=k*nk;i<k*nk+nk;i++){
        if(eta(i)<0){
          eta(i) = 0;
        }
      }
      z.col(k) = tmp.slice(k)*(beta-uini.col(k)/pho+xk.t()*(y.subvec(k*nk,k*nk+nk-1)-xi.subvec(k*nk,k*nk+nk-1)+eta.subvec(k*nk,k*nk+nk-1)+vini.subvec(k*nk,k*nk+nk-1)/pho));     
      yx.subvec(k*nk,k*nk+nk-1) = y.subvec(k*nk,k*nk+nk-1)-xk*z.col(k);
      u.col(k) = uini.col(k)+pho*(z.col(k)-beta);
      v.subvec(k*nk,k*nk+nk-1) = vini.subvec(k*nk,k*nk+nk-1)+pho*(yx.subvec(k*nk,k*nk+nk-1)-xi.subvec(k*nk,k*nk+nk-1)+eta.subvec(k*nk,k*nk+nk-1));        
      auto finish_map = std::chrono::high_resolution_clock::now();
      std::chrono::duration<double> elapsed_map = finish_map - start_map;
      map(k) = elapsed_map.count();     
    }
    max_map = map(map.index_max());
    time = time + max_map;
    if(funname == "mcp"){
      loss = tau*accu(xi)+(1-tau)*accu(eta)+gmcp2(beta, lambda, a);
    }
    else{
      loss = tau*accu(xi)+(1-tau)*accu(eta)+gscad2(beta, lambda, a);
    }
    distance = abs(loss-lossold);
    traceloss(iteration) = lossold;
    lossold = loss;
    betaini = beta, zini = z, uini = u;
    xiini = xi, etaini = eta, vini=v;
    iteration = iteration+1;
  }    
  final(0) = sum(abs(beta-betatrue));
  final(1) = time;
  final(2) = iteration;
  return final;
  //return traceloss;
}
